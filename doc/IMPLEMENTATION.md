# nodeproxy
Single process composed of two parts, as described in this document.


## Cluster ports proxy

### Goal
To listen to range of ports (`clusterPorts`) and to proxy the connections to the cluster hosts.
This proxy tries to reach for every `host:32767`, checking if it accepts the `clusterPort` connection or not.
The range of ports are listed in the proxy configuration file.

*Example*:
Consider a _haproxy_ _frontend_ which binds to `27017`; that _frontend_ then matches and invokes a _backend_, which proxies to `proxyIP:clusterPort`. In this example, _haproxy_ targets a `clusterPort` directly. This proxy is then responsible to listen to that `clusterPort` and does the round robin pass over all other `proxyIPs` on port `32767`. *Important*: This connection needs to be wrapped in _proxy-protocol_ header.

*Important*: This only handles traffic coming from _haproxy_ and _pod_. Requests coming from haproxy is exactly as if coming from another pod.
*Important*: *NO* traffic from other copies of this proxy is to be expected!
*Important*: Traffic may or may not include the _proxy-protocol_ header. _haproxy_ will *always* send _proxy-protocol_ when connecting to `clusterPorts`. Pods will most often *not* send _proxy-protocol_. In practice, _haproxy_ will always send proxy headers, then site pods (say, via _Nginx_) will be the ones expecting _proxy-protocol_ headers. Because they want the actual `clientIP` in the access logs. For other internal routing, proxy protocol is less useful becase internal IPs are often irrelevant.
*Important*: connections to clusterPort 29999 (by user/pod/haproxy) does not need PP, because it is given that we are targeting port 29999!

### Configuration
A list of hosts (host-router addresses) generated by _Simplenetes_. This configuration is the same for all hosts.

> reference: [ipA:32767\n]

_hosts.txt_:
```txt
ipA:32767
ipB:32767
```

### Reference algorithm
>I would figure some wrapping is necessary, sending proxy-protocol and then getting one line back saying "go ahead\n" or "go away\n"
>So if hostA:32767 has no clusterPort mapping or it has but no one is answering then it replies "go away"

0. Read _hosts.txt_. Keep checking the file for updates. *Important*: no manual reloads with _HUP_.

1. Listen to range of `clusterPorts`.

2. Accept _TCP_ connection (this is from a pod on the same host wanting to connect to another pod anywhere in the cluster).

3. For each _Address_, connect to it and send a oneliner as: _"ClientIP ClusterPort"_ (this is a proxy-protocol oneliner. I'm missing a few fields, but those two are the important ones. _ClientIP_ is not important really pod-pod communication, but when _Ingress_ is proxying traffic it will forward the actual _Client IP_ of the user thanks to this).
*Important related reference*: `PROXY TCP4 192.168.0.1 192.168.0.11 56324 443\r\n`. Link: https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt

4. If connection fails or if reading back one-liner "go away", then kill socket and move to next host-router address in list.

5. If reading back one-liner "go ahead", we can expect the other end to setup the connection to the pod, and we can start proxying traffic between the pods.

6. Detect hangups and close down sockets.


## Local ports proxy

### Goal
Listening to specific incoming connections on port `32767` and proxy those connections to local ports, in sequenced order. Exits upon first success or on failure at the end of the local ports list.
This serves for inter-proxy communication purposes only!
*Important*: This only handles traffic coming from other proxies!
*Important*: *NO* traffic from haproxy (with or without send-proxy) or pods is to be expected!
*Important*: proxy protocol is *required*.
*Important*: single port `32767`.
*Important*: no manual reloads with _HUP_.

### Ports specification

- `clusterPorts` range: [1025, 29999]
- `hostPorts` range: [30000, 32000]. Note: `700` ports are set as "reserved".

### Configuration
Configuration is specific to each host, generated by each _Daemon_. This configuration is bound to frequently change as it gets modified according to all port bindings and cluster ports existing on a given host.

> proxy.conf is a file with one line, space separated fields. Each field is "clusterPort:hostPort:maxConn(Int):sendProxy(textual boolean, true/false)"
_ports.conf_:
```conf
clusterPortA:hostPort1:100:true
clusterPortB:hostPort2:100:false
```
*Important*: The last line must be `"### EOF"`. If that line is not there, ignore the file and read again soon.

_ports.conf_:
```conf
clusterPortA:hostPort1:100:true
clusterPortB:hostPort2:100:false
[...]
### EOF
```
*Important*: The last line must be `"### EOF"`, this marks that the configuration file is ready to be written.

> the format is possibly multiline, but each line can have multiple of those fields
> because each line comes from one pod.
_ports.conf_:
```conf
clusterPortA:hostPort1:100:true clusterPortA:hostPort2:100:false
clusterPortB:hostPort10:100:false clusterPortB:hostPort11:100:false
[...]
### EOF
```
*Important*: there are no groupings as `clusterPort:[hostPort]`.

>A line can start with a "#", then it is to be ignored as a comment (this happens when a pod is not ready to receive traffic).
```conf
#clusterPortA:hostPort1:100:true clusterPortA:hostPort2:100:false
clusterPortB:hostPort10:100:false clusterPortB:hostPort11:100:false
[...]
### EOF
```

### Reference algorithm

0. Read configuration file, _proxy.conf_. Reread and detect changes. *Important*: no manual reloads with _HUP_.

1. Listen to port `32767` and accept connection. Expect _proxy-protocol_ one-liner to be sent by other side.

2. Extract `clusterPort` field from previous step.

3. If there is such a `clusterPort:[hostPort]` mapping, and it is active, then send back one-liner "go ahead"

4. Else send "go away"

5. If 3 is true, make connection to one `hostPort`.

6. `clusterPorts` when connected to `hostPorts`, could expect _proxy-protocol_, as stated in the proxy configuration.
When a backend nginx server in _haproxy_ is marked as _accept-proxy_ (nginx option), _haproxy_ send that initial oneliner containing _Client IP_, original port. If in the _proxy.conf_ that specific `hostPort` is marked as `sendProxy=true`, then the proxy sends a _proxy-protocol_ one-liner directly on the new socket so that the pod (running nginx with the accept-proxy option) can see the _"ClientIP"_.
*Important*: When `sendProxy=true`, that `hostPort` always sends the initial oneliner. Example: `PROXY TCP4 192.168.0.1 192.168.0.11 56324 443\r\n`. Link: https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt
*Important*: Accept-proxy is how one can configure nginx to expect that one-liner
*Important*: nginx will then read the one liner and adjust ClientIP variable
*Important*: since proxy to proxy communication is 100% internal, we don't actually have to conform to proxy protocol. We could just use our own header line


7. Else, just start proxying traffic, detect shutdowns, etc.
